//spellchecker:words status
package status

//spellchecker:words html template strconv time github wisski distillery internal models phpx
import (
	"fmt"
	"html/template"
	"strconv"
	"time"

	"github.com/FAU-CDI/wisski-distillery/internal/models"
	"github.com/FAU-CDI/wisski-distillery/internal/phpx"
)

// WissKI provides information about a single WissKI.
type WissKI struct {
	Time  time.Time // Time this info was built
	Error error     // error during fetching this information

	Slug string // slug
	URL  string // complete URL, including http(s)

	// golang html requirements.
	// Note that the html in templates may contain dirty html.
	Requirements []Requirement

	Locked bool // Is this instance currently locked?

	// Information about the running instance
	Running     bool
	LastRebuild time.Time
	LastUpdate  time.Time
	LastCron    time.Time

	DrupalVersion string // current drupal version
	Theme         string // current default theme

	// Statistics of the WissKI
	Statistics Statistics

	// List of backups made
	Snapshots []models.Export

	// List of SSH Keys that have access to this server
	SSHKeys []string

	// WissKI content information
	NoPrefixes   bool              // TODO: Move this into the database
	Prefixes     []string          // list of prefixes
	Pathbuilders map[string]string // all the pathbuilders
	Users        []DrupalUser      // all the known users
	Grants       []models.Grant

	// installed drupal modules
	Modules []DrushExtendedModuleInfo
}

// Checks if this information is ok OK
func (wisski WissKI) OK() bool {
	return wisski.Error == nil
}

// Requirement represents a drupal requirement or status check.
type Requirement struct {
	ID          string        `json:"id"`
	Title       string        `json:"title"`
	Weight      int           `json:"weight"`
	Severity    int           `json:"severity"`
	Value       template.HTML `json:"value"`
	Description template.HTML `json:"description"`
}

func (req Requirement) Level() template.HTML {
	switch req.Severity {
	case -1:
		return "<span class='info-chip note'>Note</span>"
	case 0:
		return "<span class='info-chip info'>Info</span>"
	case 1:
		return "<span class='info-chip warning'>Warning</span>"
	case 2:
		return "<span class='info-chip error'>Error</span>"
	}
	return template.HTML(strconv.Itoa(req.Severity)) // #nosec G203 -- integers are safe html
}

// Statistics holds statistics generated by the WissKI module.
type Statistics struct {
	Activity struct {
		MostVisited string `json:"mostVisited"`
		PageVisits  []struct {
			URL    string `json:"url"`
			Visits int    `json:"visits"`
		} `json:"pageVisits"`
		TotalEditsLastWeek int `json:"totalEditsLastWeek"`
	} `json:"activity"`
	Bundles     BundleStatistics `json:"bundles"`
	Triplestore struct {
		Graphs []struct {
			URI   string `json:"uri"`
			Count int    `json:"triples"`
		} `json:"graphStatistics"`
		Total int `json:"totalTriples"`
	} `json:"triplestore"`
	Users struct {
		LastLogin  string `json:"lastLogin"`
		TotalUsers int    `json:"totalUsers"`
	} `json:"users"`
}

type BundleStatistics struct {
	Bundles []struct {
		Label       string `json:"label"`
		MachineName string `json:"machineName"`

		Count int `json:"entities"`

		LastEdit phpx.Timestamp `json:"lastEdit"`

		MainBundle phpx.Boolean `json:"mainBundle"`
	} `json:"bundleStatistics"`
	TotalBundles     int `json:"totalBundles"`
	TotalMainBundles int `json:"totalMainBundles"`
}

func (bs BundleStatistics) TotalCount() (total int) {
	for _, bundle := range bs.Bundles {
		total += bundle.Count
	}
	return
}

type LastEdit struct {
	Time  time.Time
	Valid bool
}

// LastEdit returns the last time any bundle was edited, and if any edit was bigger than the reference time.
func (bs BundleStatistics) LastEdit() (le LastEdit) {
	for _, bundle := range bs.Bundles {
		time := bundle.LastEdit.Time()
		// skip invalid times
		if time.Unix() <= 0 {
			continue
		}
		if time.After(le.Time) {
			le.Valid = true
			le.Time = time
		}
	}
	return
}

func (bs BundleStatistics) Summary() string {
	totalCount := bs.TotalCount()
	if totalCount == 0 {
		return ""
	}

	entitySubject := "Entities"
	if totalCount == 1 {
		entitySubject = "Entity"
	}

	bundleSubject := "Bundles"
	if len(bs.Bundles) == 1 {
		bundleSubject = "Bundle"
	}

	return fmt.Sprintf("%d %s in %d %s", totalCount, entitySubject, len(bs.Bundles), bundleSubject)
}

type DrushExtendedModuleInfo struct {
	DrushModuleInfo
	Composer *ComposerModuleInfo `json:"composer"`
}

func (demi DrushExtendedModuleInfo) HasComposer() bool {
	return demi.Composer != nil
}

type DrushModuleInfo struct {
	Name        string `json:"name"`
	DisplayName string `json:"display_name"`

	Type    string `json:"type"`
	Path    string `json:"path"`
	Enabled bool   `json:"enabled"`
	Version string `json:"version"`
}

type ComposerModuleInfo struct {
	Name    string `json:"name"`
	Path    string `json:"path"`
	Version string `json:"version"`
}
